//所有权：rust通过所有权管理内存，编译器在编译时就会通过所有权规则对内存的使用进行检查
fn main() {
    //作用域
    {
        let a:u32 = 1;
        //这里可以打印
        println!("a: {}", a);
    }
    //这里时无法打印的，rust变量、对象的作用域是他所在的第一个{}结束截止
    //println!("a={}", a);

    //对象的回收 例1
    {
        let aa=String::from("hello");
        let bb=aa;
        //这里是没有办法访问到aa的，对于对象类型分配在堆中，rust的直接对象赋值采用的是类似浅拷贝的方式
        //并且rust会把赋值对象回收只保留被赋值对象，因为rust认为aa和bb都指向同一块内存
        //使用bb和aa没有什么差别，并且作用域结束也会被回收，所以就提前进行了回收
        //println!("aa={}", aa);
    }
    //对象回收 例2
    {
        let x:u32=1;
        let y=x;
        //这里的x是可以打印的，因为对于类似整型，浮点，布尔，元组这些基本类型对象
        //他们被分配在栈上是没有内存指向的，他们的值直接存储在对象属性信息中（类似深拷贝）
        println!("x={}", x);
    }

    //对于上面的例子如果我们想同时使用aa和bb怎么操作呢？我们可以用clone进行深拷贝
    {
        let aa=String::from("hello");
        let bb=aa.clone();
        println!("aa={}", aa);
    }
}
